# Replace PayForFibreHandler with FibreTx Wrapper Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Replace the `PayForFibreHandler` callback interface with a self-contained `FibreTx` proto wrapper (type ID `"FIBR"`), so go-square can detect and handle Fibre transactions without external callbacks — the same pattern used for `BlobTx`.

**Architecture:** Add a `FibreTx` protobuf message that bundles raw SDK tx bytes + system blob. celestia-app wraps MsgPayForFibre transactions during PrepareProposal using `MarshalFibreTx`, go-square detects them via the `"FIBR"` type ID using `UnmarshalFibreTx`. The `PayForFibreHandler` interface and all handler parameters are removed. Builder's `AppendPayForFibreTx` + `AppendSystemBlob` merge into a single atomic `AppendFibreTx`.

**Tech Stack:** Go, protobuf (buf), testify

**Branch:** `feature/fibre` (PR #223)

---

### Task 1: Add FibreTx proto message

**Files:**

- Modify: `proto/blob/v4/blob.proto`
- Regenerate: `proto/blob/v4/blob.pb.go`

**Step 1: Add FibreTx message to proto file**

Add after the `IndexWrapper` message in `proto/blob/v4/blob.proto`:

```protobuf
// FibreTx wraps an encoded sdk.Tx that contains a MsgPayForFibre message
// with the system-level blob generated by the state machine. This wrapper
// is used internally during square construction and is never stored by
// CometBFT, so standard transaction querying works.
message FibreTx {
  bytes tx = 1;
  BlobProto system_blob = 2;
  string type_id = 3;
}
```

**Step 2: Regenerate protobuf Go code**

Run: `make proto-gen`
Expected: `proto/blob/v4/blob.pb.go` is updated with `FibreTx` type.

**Step 3: Verify the generated code compiles**

Run: `go build ./...`
Expected: clean build, no errors.

**Step 4: Commit**

```bash
git add proto/blob/v4/blob.proto proto/blob/v4/blob.pb.go
git commit -m "feat: add FibreTx proto message"
```

---

### Task 2: Add tx/fibre_tx.go with marshal/unmarshal

**Files:**

- Create: `tx/fibre_tx.go`
- Create: `tx/fibre_tx_test.go`

**Step 1: Write the failing test**

Create `tx/fibre_tx_test.go`:

```go
package tx_test

import (
	"bytes"
	"testing"

	"github.com/celestiaorg/go-square/v4/share"
	"github.com/celestiaorg/go-square/v4/tx"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestMarshalUnmarshalFibreTx(t *testing.T) {
	ns := share.MustNewV0Namespace(bytes.Repeat([]byte{1}, share.NamespaceVersionZeroIDSize))
	signer := bytes.Repeat([]byte{0xAA}, share.SignerSize)
	commitment := bytes.Repeat([]byte{0xFF}, share.FibreCommitmentSize)
	systemBlob, err := share.NewV2Blob(ns, 1, commitment, signer)
	require.NoError(t, err)

	rawTx := []byte("raw-sdk-tx-bytes")

	marshaled, err := tx.MarshalFibreTx(rawTx, systemBlob)
	require.NoError(t, err)

	fibreTx, isFibreTx, err := tx.UnmarshalFibreTx(marshaled)
	require.NoError(t, err)
	require.True(t, isFibreTx)
	require.Equal(t, rawTx, fibreTx.Tx)
	require.Equal(t, systemBlob.Namespace(), fibreTx.SystemBlob.Namespace())
	require.Equal(t, systemBlob.Data(), fibreTx.SystemBlob.Data())
	require.Equal(t, systemBlob.ShareVersion(), fibreTx.SystemBlob.ShareVersion())
	require.Equal(t, systemBlob.Signer(), fibreTx.SystemBlob.Signer())
}

func TestUnmarshalFibreTxRejectsNonFibreTx(t *testing.T) {
	// A regular tx should not be identified as a FibreTx
	_, isFibreTx, _ := tx.UnmarshalFibreTx([]byte("not-a-fibre-tx"))
	assert.False(t, isFibreTx)
}

func TestUnmarshalFibreTxRejectsBlobTx(t *testing.T) {
	// A BlobTx should not be identified as a FibreTx
	ns := share.MustNewV0Namespace(bytes.Repeat([]byte{1}, share.NamespaceVersionZeroIDSize))
	blob, err := share.NewV0Blob(ns, []byte("blob-data"))
	require.NoError(t, err)

	blobTxBytes, err := tx.MarshalBlobTx([]byte("inner-tx"), blob)
	require.NoError(t, err)

	_, isFibreTx, _ := tx.UnmarshalFibreTx(blobTxBytes)
	assert.False(t, isFibreTx)
}

func TestMarshalFibreTxRejectsNilBlob(t *testing.T) {
	_, err := tx.MarshalFibreTx([]byte("tx"), nil)
	require.Error(t, err)
}

func TestMarshalFibreTxRejectsEmptyBlob(t *testing.T) {
	_, err := tx.MarshalFibreTx([]byte("tx"), &share.Blob{})
	require.Error(t, err)
}
```

**Step 2: Run test to verify it fails**

Run: `go test ./tx/ -run TestMarshalUnmarshalFibreTx -v`
Expected: FAIL — `tx.MarshalFibreTx` and `tx.UnmarshalFibreTx` don't exist.

**Step 3: Write the implementation**

Create `tx/fibre_tx.go`:

```go
package tx

import (
	"errors"

	v4 "github.com/celestiaorg/go-square/v4/proto/blob/v4"
	"github.com/celestiaorg/go-square/v4/share"
	"google.golang.org/protobuf/proto"
)

const (
	// ProtoFibreTxTypeID is included in each encoded FibreTx to help prevent
	// decoding binaries that are not actually FibreTxs.
	ProtoFibreTxTypeID = "FIBR"
)

// FibreTx wraps a MsgPayForFibre SDK transaction with the system-level blob
// generated by the state machine. This wrapper is only used internally during
// square construction (PrepareProposal/ProcessProposal) and is never stored by
// CometBFT, so standard transaction querying works.
type FibreTx struct {
	Tx         []byte
	SystemBlob *share.Blob
}

// UnmarshalFibreTx attempts to unmarshal a transaction into a FibreTx. It
// returns a boolean indicating if the bytes are of type FibreTx and an error
// if there is a problem with decoding.
func UnmarshalFibreTx(tx []byte) (*FibreTx, bool, error) {
	fTx := v4.FibreTx{}
	err := proto.Unmarshal(tx, &fTx)
	if err != nil {
		return nil, false, err
	}
	if fTx.TypeId != ProtoFibreTxTypeID {
		return nil, false, errors.New("invalid type id")
	}
	if fTx.SystemBlob == nil {
		return nil, true, errors.New("no system blob provided")
	}
	systemBlob, err := share.NewBlobFromProto(fTx.SystemBlob)
	if err != nil {
		return nil, true, err
	}
	return &FibreTx{
		Tx:         fTx.Tx,
		SystemBlob: systemBlob,
	}, true, nil
}

// MarshalFibreTx creates a FibreTx using a MsgPayForFibre SDK transaction
// and a system-level blob. The system blob must be a share version 2 blob.
func MarshalFibreTx(tx []byte, systemBlob *share.Blob) ([]byte, error) {
	if systemBlob == nil || systemBlob.IsEmpty() {
		return nil, errors.New("system blob must be provided")
	}
	fTx := &v4.FibreTx{
		Tx: tx,
		SystemBlob: &v4.BlobProto{
			NamespaceId:      systemBlob.Namespace().ID(),
			NamespaceVersion: uint32(systemBlob.Namespace().Version()),
			ShareVersion:     uint32(systemBlob.ShareVersion()),
			Signer:           systemBlob.Signer(),
			Data:             systemBlob.Data(),
		},
		TypeId: ProtoFibreTxTypeID,
	}
	return proto.Marshal(fTx)
}
```

**Step 4: Run tests to verify they pass**

Run: `go test ./tx/ -v`
Expected: all tests pass.

**Step 5: Commit**

```bash
git add tx/fibre_tx.go tx/fibre_tx_test.go
git commit -m "feat: add FibreTx marshal/unmarshal in tx package"
```

---

### Task 3: Replace PayForFibreHandler with FibreTx detection in square.go

**Files:**

- Modify: `square.go` (remove `PayForFibreHandler` interface, update `Construct`, `TxShareRange`, `BlobShareRange`, `validateTxOrdering`, `populateBuilder`)

**Step 1: Remove PayForFibreHandler interface**

Delete the `PayForFibreHandler` interface definition and remove `handler` parameters from:

- `validateTxOrdering` — use `tx.UnmarshalFibreTx` instead of `handler.IsPayForFibreTx`
- `populateBuilder` — use `tx.UnmarshalFibreTx` instead of `handler.IsPayForFibreTx` and `handler.CreateSystemBlob`
- `Construct` — remove `handler` param and nil check
- `TxShareRange` — remove `handler` param and nil check
- `BlobShareRange` — remove `handler` param and nil check

In `validateTxOrdering`, the detection flow becomes:

```go
func validateTxOrdering(txs [][]byte) error {
	seenBlobTx := false
	seenFibreTx := false
	for idx, txBytes := range txs {
		_, isBlobTx, err := tx.UnmarshalBlobTx(txBytes)
		if err != nil && isBlobTx {
			return fmt.Errorf("unmarshalling blob tx at index %d: %w", idx, err)
		}
		if isBlobTx {
			seenBlobTx = true
			if seenFibreTx {
				return fmt.Errorf("blob tx at index %d cannot be appended after pay-for-fibre tx", idx)
			}
			continue
		}
		_, isFibreTx, err := tx.UnmarshalFibreTx(txBytes)
		if err != nil && isFibreTx {
			return fmt.Errorf("unmarshalling fibre tx at index %d: %w", idx, err)
		}
		if isFibreTx {
			seenFibreTx = true
			continue
		}
		if seenBlobTx {
			return fmt.Errorf("normal tx at index %d cannot be appended after blob tx", idx)
		}
		if seenFibreTx {
			return fmt.Errorf("normal tx at index %d cannot be appended after pay-for-fibre tx", idx)
		}
	}
	return nil
}
```

In `populateBuilder`, replace the handler calls:

```go
func populateBuilder(builder *Builder, txs [][]byte) error {
	for idx, txBytes := range txs {
		blobTx, isBlobTx, err := tx.UnmarshalBlobTx(txBytes)
		if err != nil && isBlobTx {
			return fmt.Errorf("unmarshalling blob tx at index %d: %w", idx, err)
		}
		if isBlobTx {
			added, err := builder.AppendBlobTx(blobTx)
			if err != nil {
				return fmt.Errorf("appending blob tx at index %d: %w", idx, err)
			}
			if !added {
				return fmt.Errorf("not enough space to append blob tx at index %d", idx)
			}
			continue
		}
		fibreTx, isFibreTx, err := tx.UnmarshalFibreTx(txBytes)
		if err != nil && isFibreTx {
			return fmt.Errorf("unmarshalling fibre tx at index %d: %w", idx, err)
		}
		if isFibreTx {
			added, err := builder.AppendFibreTx(fibreTx)
			if err != nil {
				return fmt.Errorf("appending fibre tx at index %d: %w", idx, err)
			}
			if !added {
				return fmt.Errorf("not enough space to append fibre tx at index %d", idx)
			}
			continue
		}
		if !builder.AppendTx(txBytes) {
			return fmt.Errorf("not enough space to append tx at index %d", idx)
		}
	}
	return nil
}
```

Update public function signatures:

```go
func Construct(txs [][]byte, maxSquareSize, subtreeRootThreshold int) (Square, error)
func TxShareRange(txs [][]byte, txIndex, maxSquareSize, subtreeRootThreshold int) (share.Range, error)
func BlobShareRange(txs [][]byte, txIndex, blobIndex, maxSquareSize, subtreeRootThreshold int) (share.Range, error)
```

**Step 2: Verify this compiles (tests won't pass yet — Builder.AppendFibreTx doesn't exist)**

Run: `go build ./...`
Expected: compile error on `builder.AppendFibreTx` — that's expected, handled in Task 4.

**Do NOT commit yet** — Task 3 and Task 4 must be committed together since they're co-dependent.

---

### Task 4: Merge AppendPayForFibreTx + AppendSystemBlob into AppendFibreTx

**Files:**

- Modify: `builder.go` (replace `AppendPayForFibreTx` + `AppendSystemBlob` with `AppendFibreTx`)

**Step 1: Replace the two methods with one atomic method**

Remove `AppendPayForFibreTx(tx []byte) bool` and `AppendSystemBlob(blob *share.Blob) (bool, error)`.

Add:

```go
// AppendFibreTx attempts to allocate a FibreTx to the square. It atomically
// adds the raw SDK tx bytes to PayForFibreTxs (compact shares) and the system
// blob to Blobs (sparse shares). It returns false if there is not enough space.
func (b *Builder) AppendFibreTx(fibreTx *tx.FibreTx) (bool, error) {
	if fibreTx.SystemBlob.ShareVersion() != share.ShareVersionTwo {
		return false, fmt.Errorf("system blobs must use ShareVersionTwo, got version %d", fibreTx.SystemBlob.ShareVersion())
	}

	pffShareDiff := b.PayForFibreCounter.Add(len(fibreTx.Tx))

	element, err := newElement(fibreTx.SystemBlob, NoPfbIndex, NoPfbIndex, b.subtreeRootThreshold)
	if err != nil {
		b.PayForFibreCounter.Revert()
		return false, err
	}
	blobShareCount := element.maxShareOffset()

	totalSizeChange := pffShareDiff + blobShareCount
	if b.canFit(totalSizeChange) {
		b.PayForFibreTxs = append(b.PayForFibreTxs, fibreTx.Tx)
		b.Blobs = append(b.Blobs, element)
		b.currentSize += totalSizeChange
		b.lastPayForFibreTxSizeChange = totalSizeChange
		b.payForFibreTxReverted = false
		b.done = false
		return true, nil
	}
	b.PayForFibreCounter.Revert()
	return false, nil
}
```

Update `RevertLastPayForFibreTx` to also remove the system blob:

```go
func (b *Builder) RevertLastPayForFibreTx() error {
	if len(b.PayForFibreTxs) == 0 {
		return errors.New("no pay-for-fibre transactions to revert")
	}
	if b.payForFibreTxReverted {
		return errors.New("cannot revert: last pay-for-fibre transaction has already been reverted")
	}

	b.PayForFibreTxs = b.PayForFibreTxs[:len(b.PayForFibreTxs)-1]
	// Remove the last system blob (NoPfbIndex sentinel)
	for i := len(b.Blobs) - 1; i >= 0; i-- {
		if b.Blobs[i].PfbIndex == NoPfbIndex {
			b.Blobs = append(b.Blobs[:i], b.Blobs[i+1:]...)
			break
		}
	}
	b.PayForFibreCounter.Revert()
	b.currentSize -= b.lastPayForFibreTxSizeChange
	b.payForFibreTxReverted = true
	b.done = false

	return nil
}
```

Also update the `NoPfbIndex` constant name (currently `FibreBlobIndex` in the PR):

```go
const NoPfbIndex = -1
```

Remove the `AppendSystemBlob` method entirely.

**Step 2: Add tx import to builder.go**

Add `"github.com/celestiaorg/go-square/v4/tx"` to the import block.

**Step 3: Verify compilation**

Run: `go build ./...`
Expected: compile errors in tests only (tests still reference old API).

**Do NOT commit yet** — commit together with Task 3 after tests are updated in Task 5.

---

### Task 5: Update all tests for the new API

**Files:**

- Modify: `square_test.go`
- Modify: `builder_test.go`
- Modify: `square_benchmark_test.go`

**Step 1: Update square_test.go**

1. Remove `mockPayForFibreHandler` struct and its methods entirely.
2. Replace all `payForFibreTx := []byte("pay-for-fibre-tx")` with properly marshaled FibreTx bytes using `tx.MarshalFibreTx`.
3. Remove `handler` parameter from all calls to `Construct`, `TxShareRange`, `BlobShareRange`.
4. Remove the "nil handler returns error" test case.
5. Update `TestValidateTxOrdering` test cases to use marshaled FibreTx bytes instead of raw strings.
6. Update `TestSquareTxShareRangeWithPayForFibre` to use marshaled FibreTx bytes.

Helper to create FibreTx bytes in tests:

```go
func newFibreTxBytes(t *testing.T) []byte {
	t.Helper()
	ns := share.MustNewV0Namespace(bytes.Repeat([]byte{1}, share.NamespaceVersionZeroIDSize))
	signer := bytes.Repeat([]byte{0xAA}, share.SignerSize)
	commitment := bytes.Repeat([]byte{0xFF}, share.FibreCommitmentSize)
	systemBlob, err := share.NewV2Blob(ns, 1, commitment, signer)
	require.NoError(t, err)
	fibreTxBytes, err := tx.MarshalFibreTx([]byte("pay-for-fibre-sdk-tx"), systemBlob)
	require.NoError(t, err)
	return fibreTxBytes
}
```

**Step 2: Update builder_test.go**

1. Replace `builder.AppendPayForFibreTx(rawBytes)` calls with `builder.AppendFibreTx(fibreTx)` where `fibreTx` is a `*tx.FibreTx`.
2. Remove `mustAppendSystemBlob` helper and `TestBuilderAppendSystemBlob`.
3. Update `TestBuilderExportWithSystemBlobs` — system blobs are now added via `AppendFibreTx`, not standalone `AppendSystemBlob`.
4. Update `TestBuilderAppendPayForFibreTx` to use `AppendFibreTx`.
5. Update `TestBuilderRevertPayForFibreTx` — revert now also removes the system blob.
6. Update `TestBuilderExportWithMixedTransactions` to use `AppendFibreTx`.
7. Update `TestBuilderRevertMixedWithPayForFibreTx` — revert now also removes system blob from `Blobs`.
8. Update `TestBuilderNumTxsWithPayForFibreTx`.
9. Update `TestBuilderIsEmptyWithPayForFibreTx`.
10. Update `TestBuilderFindTxShareRangeWithPayForFibre` — use `AppendFibreTx` instead of `AppendPayForFibreTx`.

**Step 3: Update square_benchmark_test.go if it references PayForFibreHandler**

Check and update any benchmark tests that pass handler parameters.

**Step 4: Run all tests**

Run: `go test ./... -v -count=1`
Expected: all tests pass.

**Step 5: Commit Tasks 3+4+5 together**

```bash
git add square.go builder.go square_test.go builder_test.go square_benchmark_test.go
git commit -m "refactor!: replace PayForFibreHandler with FibreTx wrapper

Remove the PayForFibreHandler callback interface and replace it with
FibreTx, a self-contained protobuf wrapper (type ID \"FIBR\") that
bundles MsgPayForFibre SDK tx bytes with the system-level blob.

This eliminates the handler parameter from Construct, TxShareRange,
and BlobShareRange. go-square now detects Fibre transactions the same
way it detects BlobTx — by magic type ID prefix.

Builder.AppendPayForFibreTx and AppendSystemBlob are merged into a
single atomic AppendFibreTx method."
```

---

### Task 6: Run linter and fix any issues

**Files:**

- Possibly any file touched above

**Step 1: Run linter**

Run: `make lint`
Expected: clean or minor issues.

**Step 2: Fix any lint issues**

Apply `make fmt` or manual fixes as needed.

**Step 3: Run full test suite with race detection**

Run: `go test ./... -v -timeout 5m -race`
Expected: all tests pass.

**Step 4: Commit if any fixes were needed**

```bash
git add -A
git commit -m "fix: address lint issues"
```

---

### Task 7: Force-push to feature/fibre branch

**Step 1: Push to the PR branch**

Run: `git push origin HEAD:feature/fibre --force-with-lease`

Note: This requires user confirmation since it's a force push to a shared branch.
